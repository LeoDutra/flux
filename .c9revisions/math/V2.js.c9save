{"ts":1348294705826,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n/*\n * Flux JavaScript Library\n * Copyright (c) 2010 Leonardo Dutra Constancio\n * MIT License (http://jsflux.googlecode.com/svn/trunk/mit-license.txt)\n */\nflux.V2 = function (x, y)\n{\n    if (this instanceof flux.V2)\n    {\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n};\nflux.V2.interpolate = function (vInitial, vFinal, changeAmount)\n{\n    return new flux.V2((1 - changeAmount) * vInitial.x + changeAmount * vFinal.x, (1 - changeAmount) * vInitial.y + changeAmount * vFinal.y);\n};\nflux.V2.prototype = {\n\n    set: function (v)\n    {\n        this.x = v.x;\n        this.y = v.y;\n    },\n\n    setXY: function (x, y)\n    {\n        this.x = x;\n        this.y = y;\n    },\n    add: function (v)\n    {\n        this.x += v.x;\n        this.y += v.y;\n    },\n    addXY: function (x, y)\n    {\n        this.x += x;\n        this.y += y;\n    },\n    sub: function (v)\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n    },\n    multScalar: function (s)\n    {\n        this.x *= s;\n        this.y *= s;\n    },\n    divScalar: function (s)\n    {\n        this.x /= s;\n        this.y /= s;\n    },\n    min: function (v)\n    {\n        if (v.x < this.x) this.x = v.x;\n        if (v.y < this.y) this.y = v.y;\n    },\n    max: function (v)\n    {\n        if (this.x < v.x) this.x = v.x;\n        if (this.y < v.y) this.y = v.y;\n    },\n    isValid: function ()\n    {\n        return !(isNaN(this.x) || isNaN(this.y)) && isFinite(this.x) && isFinite(this.y);\n    },\n    clone: function ()\n    {\n        return this.isValid() ? new flux.V2(this.x, this.y) : new flux.V2();\n    },\n    lengthSqr: function ()\n    {\n        return this.x * this.x + this.y * this.y;\n    },\n    length: function ()\n    {\n        return Math.sqrt(this.lengthSqr());\n    },\n    interpolate: function (vInitial, vFinal, changeAmount)\n    {\n        this.x = (1 - changeAmount) * vInitial.x + changeAmount * vFinal.x;\n        this.y = (1 - changeAmount) * vInitial.y + changeAmount * vFinal.y;\n    },\n    interpolateSelf: function (vFinal, changeAmount)\n    {\n        this.interpolate(this, vFinal, changeAmount);\n    },\n    normalize: function (length)\n    {\n        if ((length = length || this.length())) this.divScalar(length);\n        else this.x = this.y = 0;\n    },\n    distanceSqr: function (v)\n    {\n        var x = this.x - v.x;\n        return x * x + (v = this.y - v.y) * v;\n    },\n    distance: function (v)\n    {\n        return Math.sqrt(this.distanceSqr(v));\n    },\n    near: function (v, refDistance) /*true if the distance between v1 and v2 is less than dist*/\n    {\n        return this.distanceSqr(v) < refDistance * refDistance;\n    },\n    equals: function (v)\n    {\n        return this.x === v.x && this.y === v.y;\n    },\n    toString: function ()\n    {\n        return 'V2(x=' + this.x + ', y=' + this.y + ')';\n    }\n};"]],"start1":0,"start2":0,"length1":0,"length2":2791}]],"length":2791}
